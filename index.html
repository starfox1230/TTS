<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>TTS Chunked Generator</title>
  <style>
    body { background-color: #121212; color: #e0e0e0; font-family: Arial, sans-serif; margin: 0; padding: 20px; }
    .container { max-width: 900px; margin: auto; }
    input, textarea, button, select { width: 100%; padding: 10px; margin-top: 10px; border: none; border-radius: 4px; }
    input, textarea, select { background: #1e1e1e; color: #e0e0e0; }
    button { background: #1e88e5; color: #fff; cursor: pointer; }
    button:hover { background: #1565c0; }
    button:disabled { opacity: 0.5; cursor: not-allowed; }
    .row { display: flex; gap: 10px; }
    .row > * { flex: 1; }
    .audio-item { margin-top: 20px; border: 1px solid #444; padding: 10px; border-radius: 4px; background: #1e1e1e; }
    .audio-item a { color: #90caf9; text-decoration: none; }
    .audio-item a:hover { text-decoration: underline; }
    #statusMessages { margin-top: 10px; font-size: 1em; color: #90caf9; white-space: pre-wrap; }
    #charCount { margin-top: 5px; font-size: 0.9em; color: #bbb; }
    #warmUpMessage { background: #333; padding: 10px; border-radius: 4px; margin-bottom: 20px; text-align: center; }
    #advancedOptions { display: none; margin-top: 10px; }
    #advancedToggleLabel { display: none; margin-top: 10px; font-size: 0.95em; }
    #advancedToggleLabel input { width: auto; margin-right: 8px; vertical-align: middle; }
    .chunkList { margin-top: 15px; }
    .chunkRow { display:flex; align-items:center; gap:10px; padding:8px; border:1px solid #333; border-radius:6px; margin-top:8px; background:#181818;}
    .chunkRow small { color:#aaa; }
    .pill { padding:2px 8px; border-radius:999px; font-size:12px; background:#2a2a2a; color:#ddd; }
    .pill.ok { background:#1b5e20; }
    .pill.bad { background:#b71c1c; }
    .pill.run { background:#0d47a1; }
    .overlay { position: fixed; inset: 0; background: rgba(10, 10, 10, 0.8); display: flex; align-items: center; justify-content: center; z-index: 999; }
    .overlay.hidden { display: none; }
    .overlay-card { background: #1b1b1b; border: 1px solid #333; border-radius: 10px; max-width: 760px; width: 90%; padding: 20px; box-shadow: 0 12px 40px rgba(0,0,0,0.4); }
    .overlay-card h3 { margin-top: 0; }
    .overlay-meta { color: #bbb; font-size: 0.95em; margin-bottom: 12px; }
    .overlay-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 12px; margin-top: 12px; }
    .overlay-panel { background: #121212; border: 1px solid #2a2a2a; border-radius: 8px; padding: 10px; }
    .overlay-panel h4 { margin: 0 0 6px 0; font-size: 0.9em; color: #90caf9; }
    .overlay-panel pre { margin: 0; white-space: pre-wrap; word-break: break-word; color: #e0e0e0; font-family: "Segoe UI", sans-serif; }
    .overlay-actions { display: flex; gap: 10px; justify-content: flex-end; margin-top: 16px; }
    .overlay-actions button { width: auto; padding: 8px 14px; }
    .overlay-actions .secondary { background: #424242; }
  </style>

  <!-- JSZip for “Download ZIP” -->
  <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
</head>
<body>
  <div class="container">
    <div id="warmUpMessage">Warming up the server, please wait...</div>
    <h1>TTS Chunked Generator</h1>

    <input type="text" id="title" placeholder="Enter title">
    <textarea id="text" rows="6" placeholder="Enter text here"></textarea>
    <div id="charCount">Characters: 0 | Estimated cost: $0.000</div>

    <label for="model">Choose TTS Model:</label>
    <select id="model">
      <option value="gpt-4o-mini-tts" selected>GPT-4o Mini TTS (new)</option>
      <option value="tts-1">Standard TTS (old)</option>
    </select>

    <label for="voice">Choose Voice:</label>
    <select id="voice">
      <option value="alloy">Alloy</option>
      <option value="ash">Ash</option>
      <option value="ballad">Ballad</option>
      <option value="coral">Coral</option>
      <option value="echo" selected>Echo</option>
      <option value="fable">Fable</option>
      <option value="onyx">Onyx</option>
      <option value="nova">Nova</option>
      <option value="sage">Sage</option>
      <option value="shimmer">Shimmer</option>
      <option value="verse">Verse</option>
      <option value="marin">Marin</option>
      <option value="cedar">Cedar</option>
    </select>

    <label id="advancedToggleLabel">
      <input type="checkbox" id="showAdvanced">
      Show advanced options
    </label>

    <div id="advancedOptions">
      <label for="customInstr">Free-form Custom Instructions:</label>
      <textarea id="customInstr" rows="3" placeholder="e.g., Speak in a cheerful and positive tone…"></textarea>

      <div class="row">
        <div>
          <label for="chunkSize">Chunk size (chars):</label>
          <input type="number" id="chunkSize" min="500" max="6000" value="2500">
        </div>
        <div>
          <label for="concurrency">Concurrency (parallel chunks):</label>
          <select id="concurrency">
            <option value="1">1 (safest)</option>
            <option value="2">2</option>
            <option value="3">3</option>
            <option value="4">4</option>
            <option value="5">5</option>
            <option value="6">6</option>
            <option value="7">7</option>
            <option value="8">8</option>
            <option value="9">9</option>
            <option value="10">10</option>
            <option value="11">11</option>
            <option value="12">12</option>
            <option value="13">13</option>
            <option value="14">14</option>
            <option value="15">15</option>
            <option value="16">16</option>
            <option value="17">17</option>
            <option value="18">18</option>
            <option value="19">19</option>
            <option value="20">20</option>
            <option value="21">21</option>
            <option value="22">22</option>
            <option value="23">23</option>
            <option value="24">24</option>
            <option value="25">25</option>
            <option value="26">26</option>
            <option value="27">27</option>
            <option value="28">28</option>
            <option value="29">29</option>
            <option value="30" selected>30 (max)</option>
          </select>
        </div>
      </div>
    </div>

    <div class="row">
      <button id="generateBtn">Generate Audio</button>
      <button id="retryBtn" disabled>Retry failed</button>
      <button id="uploadZipBtn">Upload Zip File</button>
    </div>

    <input type="file" id="uploadZipInput" accept=".zip" style="display:none">

    <div class="row">
      <button id="downloadZipBtn" disabled>Download completed chunks (ZIP)</button>
      <button id="downloadFullBtn" disabled>Download full MP3 (concat)</button>
    </div>

    <div id="statusMessages"></div>
    <div id="audioList"></div>

    <div class="chunkList" id="chunkList"></div>
  </div>

  <div id="pasteOverlay" class="overlay hidden" role="dialog" aria-modal="true" aria-hidden="true">
    <div class="overlay-card">
      <h3>Encoding detected on paste</h3>
      <p class="overlay-meta">We cleaned the pasted text so spacing and symbols display normally. <strong>Detected:</strong> <span id="pasteIssueList"></span></p>
      <div class="overlay-grid">
        <div class="overlay-panel">
          <h4>Original</h4>
          <pre id="pasteOriginal"></pre>
        </div>
        <div class="overlay-panel">
          <h4>Cleaned</h4>
          <pre id="pasteCleaned"></pre>
        </div>
      </div>
      <div class="overlay-actions">
        <button class="secondary" id="restoreOriginalBtn">Restore original</button>
        <button id="keepCleanedBtn">Keep cleaned</button>
      </div>
    </div>
  </div>

  <script>
    const API_BASE = "https://tts-jeh9.onrender.com";

    const warmUpMessage = document.getElementById("warmUpMessage");
    const titleInput = document.getElementById("title");
    const textInput = document.getElementById("text");
    const modelSelect = document.getElementById("model");
    const voiceSelect = document.getElementById("voice");
    const charCountDiv = document.getElementById("charCount");

    const generateBtn = document.getElementById("generateBtn");
    const retryBtn = document.getElementById("retryBtn");
    const uploadZipBtn = document.getElementById("uploadZipBtn");
    const uploadZipInput = document.getElementById("uploadZipInput");

    const downloadZipBtn = document.getElementById("downloadZipBtn");
    const downloadFullBtn = document.getElementById("downloadFullBtn");

    const statusDiv = document.getElementById("statusMessages");
    const audioList = document.getElementById("audioList");
    const chunkListEl = document.getElementById("chunkList");
    const pasteOverlay = document.getElementById("pasteOverlay");
    const pasteIssueList = document.getElementById("pasteIssueList");
    const pasteOriginal = document.getElementById("pasteOriginal");
    const pasteCleaned = document.getElementById("pasteCleaned");
    const restoreOriginalBtn = document.getElementById("restoreOriginalBtn");
    const keepCleanedBtn = document.getElementById("keepCleanedBtn");

    const showAdvanced = document.getElementById("showAdvanced");
    const advancedOptions = document.getElementById("advancedOptions");
    const customInstr = document.getElementById("customInstr");
    const advancedToggle = document.getElementById("advancedToggleLabel");
    const chunkSizeInput = document.getElementById("chunkSize");
    const concurrencySelect = document.getElementById("concurrency");

    const LS_ADVANCED_SETTINGS = "tts_advanced_settings";
    const LS_ADVANCED_OPEN = "tts_advanced_open";

    // Cost estimator constants (your existing logic)
    const charsPerMinute = 920;
    const charRates = { "gpt-4o-mini-tts": 0.0006, "tts-1": 0.015 };
    const audioRatePerMin = 0.015;

    const voicesByModel = {
      "tts-1": ["alloy","echo","fable","onyx","nova","shimmer"],
      "gpt-4o-mini-tts": ["alloy","ash","ballad","coral","echo","fable","onyx","nova","sage","shimmer","verse","marin","cedar"]
    };

    // IndexedDB (simple wrapper)
    const DB_NAME = "tts_chunks_db";
    const DB_STORE = "chunks";

    function openDB() {
      return new Promise((resolve, reject) => {
        const req = indexedDB.open(DB_NAME, 1);
        req.onupgradeneeded = () => {
          const db = req.result;
          if (!db.objectStoreNames.contains(DB_STORE)) {
            db.createObjectStore(DB_STORE, { keyPath: "key" });
          }
        };
        req.onsuccess = () => resolve(req.result);
        req.onerror = () => reject(req.error);
      });
    }

    async function idbPut(key, blob, meta) {
      const db = await openDB();
      return new Promise((resolve, reject) => {
        const tx = db.transaction(DB_STORE, "readwrite");
        tx.objectStore(DB_STORE).put({ key, blob, meta, savedAt: Date.now() });
        tx.oncomplete = () => resolve();
        tx.onerror = () => reject(tx.error);
      });
    }

    async function idbGet(key) {
      const db = await openDB();
      return new Promise((resolve, reject) => {
        const tx = db.transaction(DB_STORE, "readonly");
        const req = tx.objectStore(DB_STORE).get(key);
        req.onsuccess = () => resolve(req.result || null);
        req.onerror = () => reject(req.error);
      });
    }

    async function idbGetAllByPrefix(prefix) {
      const db = await openDB();
      return new Promise((resolve, reject) => {
        const tx = db.transaction(DB_STORE, "readonly");
        const store = tx.objectStore(DB_STORE);
        const out = [];
        const cursorReq = store.openCursor();
        cursorReq.onsuccess = () => {
          const cur = cursorReq.result;
          if (!cur) return resolve(out);
          if (cur.key.startsWith(prefix)) out.push(cur.value);
          cur.continue();
        };
        cursorReq.onerror = () => reject(cursorReq.error);
      });
    }

    // Simple stable job key (so refresh/resume works for same inputs)
    async function sha256(str) {
      const data = new TextEncoder().encode(str);
      const hash = await crypto.subtle.digest("SHA-256", data);
      const bytes = Array.from(new Uint8Array(hash));
      return bytes.map(b => b.toString(16).padStart(2, "0")).join("");
    }

    function setStatus(msg) { statusDiv.innerText = msg; }

    function pad3(n) { return String(n).padStart(3, "0"); }

    function splitIntoChunks(text, chunkSize) {
      const chunks = [];
      for (let i = 0; i < text.length; ) {
        let end = Math.min(i + chunkSize, text.length);
        if (end < text.length) {
          const pi = text.lastIndexOf(".", end);
          if (pi > i) end = pi + 1;
        }
        chunks.push(text.slice(i, end));
        i = end;
      }
      return chunks;
    }

    // Concurrency pool with adaptive drop on errors
    async function runPoolAdaptive(items, workerFn, concurrencyStart, signal, onDrop) {
      let nextIndex = 0;
      let inFlight = 0;
      let max = Math.max(1, Math.floor(concurrencyStart));

      function setMax(newMax) {
        const clamped = Math.max(1, Math.floor(newMax));
        if (clamped < max) {
          max = clamped;
          onDrop?.(max);
        }
      }

      // Error-based auto-drop policy:
      // - Drop faster on 429 (rate limiting)
      // - Drop modestly on network/failed fetch/timeouts
      let recentFails = 0;

      function maybeDrop(errMsg) {
        recentFails++;

        const msg = String(errMsg || "");
        const is429 = /(^|[^0-9])429([^0-9]|$)|too many requests/i.test(msg);
        const isNet = /failed fetch|network|timeout|fetch|connection|socket|ECONN|ETIMEDOUT/i.test(msg);

        if (is429 && recentFails >= 2) {
          // Drop ~40%, but never below 3 unless already lower
          setMax(max <= 3 ? 3 : Math.max(3, Math.ceil(max * 0.6)));
          recentFails = 0;
        } else if (isNet && recentFails >= 3) {
          // Drop ~25%, but never below 3 unless already lower
          setMax(max <= 3 ? 3 : Math.max(3, Math.ceil(max * 0.75)));
          recentFails = 0;
        }
      }

      return new Promise((resolve, reject) => {
        const results = new Array(items.length);

        const pump = () => {
          if (signal?.aborted) return reject(new Error("Cancelled"));
          if (nextIndex >= items.length && inFlight === 0) return resolve(results);

          while (inFlight < max && nextIndex < items.length) {
            const my = nextIndex++;
            inFlight++;

            Promise.resolve(workerFn(items[my], my))
              .then((r) => { results[my] = r; })
              .catch((e) => {
                const msg = e?.message || String(e);
                maybeDrop(msg);
                // NOTE: workerFn should already set per-chunk status to fail/run/etc.
                // We do NOT reject; we keep processing remaining items.
              })
              .finally(() => {
                inFlight--;
                pump();
              });
          }
        };

        pump();
      });
    }

    // UI helpers
    function renderChunkRows(state) {
      chunkListEl.innerHTML = "";
      state.chunks.forEach((c, i) => {
        const row = document.createElement("div");
        row.className = "chunkRow";
        const pill = document.createElement("span");
        pill.className = "pill " + (c.status === "ok" ? "ok" : c.status === "fail" ? "bad" : c.status === "run" ? "run" : "");
        pill.textContent = c.status.toUpperCase();
        row.appendChild(pill);

        const main = document.createElement("div");
        main.style.flex = "1";
        main.innerHTML = `<div>Chunk ${i+1} / ${state.chunks.length} <small>(${c.len} chars)</small></div>
                          <small>${c.error ? ("Error: " + c.error) : ""}</small>`;
        row.appendChild(main);

        const btn = document.createElement("button");
        btn.textContent = "Retry";
        btn.style.width = "120px";
        btn.disabled = c.status !== "fail" || state.running;
        btn.onclick = async () => { await retrySpecificChunk(state, i); };
        row.appendChild(btn);

        const dl = document.createElement("button");
        dl.textContent = "Download";
        dl.style.width = "120px";
        dl.disabled = c.status !== "ok";
        dl.onclick = async () => {
          const key = `${state.jobKey}:${pad3(i)}`;
          const rec = await idbGet(key);
          if (!rec?.blob) return;
          const url = URL.createObjectURL(rec.blob);
          const a = document.createElement("a");
          a.href = url;
          a.download = `${state.title}_chunk_${pad3(i)}.mp3`;
          a.click();
          setTimeout(() => URL.revokeObjectURL(url), 2000);
        };
        row.appendChild(dl);

        chunkListEl.appendChild(row);
      });
    }

    function saveAdvancedSettings() {
      const settings = {
        chunkSize: chunkSizeInput.value,
        concurrency: concurrencySelect.value,
        instructions: customInstr.value,
      };
      localStorage.setItem(LS_ADVANCED_SETTINGS, JSON.stringify(settings));
    }

    function loadAdvancedSettings() {
      const raw = localStorage.getItem(LS_ADVANCED_SETTINGS);
      if (raw) {
        try {
          const saved = JSON.parse(raw);
          if (saved.chunkSize) chunkSizeInput.value = saved.chunkSize;
          if (saved.concurrency && concurrencySelect.querySelector(`option[value="${saved.concurrency}"]`)) {
            concurrencySelect.value = saved.concurrency;
          }
          if (typeof saved.instructions === "string") customInstr.value = saved.instructions;
        } catch {}
      }

      const savedOpen = localStorage.getItem(LS_ADVANCED_OPEN);
      if (savedOpen !== null) {
        showAdvanced.checked = savedOpen === "true";
      }
    }

    function handleAdvancedToggleVisibility(model) {
      const advancedAllowed = model === "gpt-4o-mini-tts";
      advancedToggle.style.display = advancedAllowed ? "block" : "none";

      if (!advancedAllowed) {
        showAdvanced.checked = false;
        advancedOptions.style.display = "none";
        return;
      }

      const savedOpen = localStorage.getItem(LS_ADVANCED_OPEN);
      if (savedOpen !== null) {
        showAdvanced.checked = savedOpen === "true";
      }
      advancedOptions.style.display = showAdvanced.checked ? "block" : "none";
    }

    // Model change -> voice filtering + advanced toggle
    modelSelect.addEventListener("change", () => {
      const model = modelSelect.value;
      const valid = voicesByModel[model] || [];
      voiceSelect.querySelectorAll("option").forEach(opt => {
        opt.disabled = !valid.includes(opt.value);
      });

      handleAdvancedToggleVisibility(model);

      // update estimator
      textInput.dispatchEvent(new Event("input"));
    });

    loadAdvancedSettings();
    modelSelect.dispatchEvent(new Event("change"));

    showAdvanced.addEventListener("change", () => {
      advancedOptions.style.display = showAdvanced.checked ? "block" : "none";
      localStorage.setItem(LS_ADVANCED_OPEN, showAdvanced.checked ? "true" : "false");
    });

    customInstr.addEventListener("input", saveAdvancedSettings);
    chunkSizeInput.addEventListener("input", saveAdvancedSettings);
    concurrencySelect.addEventListener("change", saveAdvancedSettings);

    // Warm-up
    window.addEventListener("load", async () => {
      try {
        await fetch(`${API_BASE}/`);
        warmUpMessage.innerText = "Server is ready!";
        setTimeout(() => warmUpMessage.style.display = "none", 2000);
      } catch {
        warmUpMessage.innerText = "Error contacting server.";
      }
    });

    // Cost estimator
    textInput.addEventListener("input", function () {
      const len = this.value.length;
      const rate = charRates[modelSelect.value] || 0;
      const textCost = (len / 1000) * rate;
      const minutes = len / charsPerMinute;
      const audioCost = minutes * audioRatePerMin;
      const totalCost = textCost + audioCost;
      charCountDiv.innerText =
        `Chars: ${len} | Text: $${textCost.toFixed(3)} + Audio: $${audioCost.toFixed(3)} = $${totalCost.toFixed(3)}`;
    });

    function decodeUrlEncoded(text) {
      const hasEncodedChunks = /%[0-9a-fA-F]{2}/.test(text);
      const hasCommonEscapes = /%0A|%0D|%20|\+/.test(text);
      if (!hasEncodedChunks || !hasCommonEscapes) return text;

      try {
        const normalized = text.replace(/\+/g, " ");
        const decoded = decodeURIComponent(normalized);
        return decoded || text;
      } catch {
        return text;
      }
    }

    function decodeHtmlEntities(text) {
      if (!/&[a-zA-Z0-9#]+;/.test(text)) return text;
      const helper = document.createElement("textarea");
      helper.innerHTML = text;
      return helper.value;
    }

    function htmlToPlainText(html) {
      const wrapper = document.createElement("div");
      wrapper.innerHTML = html;

      const blockTags = new Set(["P","DIV","LI","UL","OL","H1","H2","H3","H4","H5","H6","BLOCKQUOTE","PRE"]);
      const parts = [];

      function walk(node) {
        if (node.nodeType === Node.TEXT_NODE) {
          parts.push(node.textContent);
          return;
        }

        if (node.nodeType !== Node.ELEMENT_NODE) return;

        const tag = node.tagName;
        if (tag === "BR") {
          parts.push("\n");
          return;
        }

        node.childNodes.forEach(walk);

        if (blockTags.has(tag)) {
          parts.push("\n");
        }
      }

      wrapper.childNodes.forEach(walk);
      return parts.join("").replace(/\n{3,}/g, "\n\n").trim();
    }

    function normalizePastedText(text, html) {
      const issues = [];
      let normalized = text;

      if (html) {
        const hasTags = /<\/?[a-z][\s\S]*>/i.test(html);
        if (hasTags) {
          const fromHtml = htmlToPlainText(html);
          if (fromHtml && fromHtml !== normalized) {
            issues.push("Rich text (HTML)");
            normalized = fromHtml;
          }
        }
      }

      const urlDecoded = decodeUrlEncoded(normalized);
      if (urlDecoded !== normalized) {
        issues.push("URL-encoded characters");
        normalized = urlDecoded;
      }

      const htmlDecoded = decodeHtmlEntities(normalized);
      if (htmlDecoded !== normalized) {
        issues.push("HTML entities");
        normalized = htmlDecoded;
      }

      return { normalized, issues, changed: normalized !== text };
    }

    let lastPasteInfo = null;

    function openPasteOverlay(info) {
      pasteIssueList.textContent = info.issues.length ? info.issues.join(", ") : "Encoding detected";
      pasteOriginal.textContent = info.raw;
      pasteCleaned.textContent = info.normalized;
      pasteOverlay.classList.remove("hidden");
      pasteOverlay.setAttribute("aria-hidden", "false");
    }

    function closePasteOverlay() {
      pasteOverlay.classList.add("hidden");
      pasteOverlay.setAttribute("aria-hidden", "true");
      lastPasteInfo = null;
    }

    restoreOriginalBtn.addEventListener("click", () => {
      if (!lastPasteInfo) return;
      const { start, end, raw, normalized } = lastPasteInfo;
      const currentSlice = textInput.value.slice(start, end);
      const replaceStart = currentSlice === normalized ? start : textInput.selectionStart;
      const replaceEnd = currentSlice === normalized ? end : textInput.selectionEnd;
      textInput.setRangeText(raw, replaceStart, replaceEnd, "end");
      textInput.dispatchEvent(new Event("input"));
      closePasteOverlay();
    });

    keepCleanedBtn.addEventListener("click", () => closePasteOverlay());

    pasteOverlay.addEventListener("click", (event) => {
      if (event.target === pasteOverlay) closePasteOverlay();
    });

    textInput.addEventListener("paste", (event) => {
      const clipboardText = event.clipboardData?.getData("text/plain");
      const clipboardHtml = event.clipboardData?.getData("text/html");
      if (!clipboardText && !clipboardHtml) return;

      const rawText = clipboardText || clipboardHtml;
      const { normalized, issues, changed } = normalizePastedText(rawText, clipboardHtml);
      if (!changed) return;

      event.preventDefault();
      const start = textInput.selectionStart;
      const end = textInput.selectionEnd;
      textInput.setRangeText(normalized, start, end, "end");
      textInput.dispatchEvent(new Event("input"));

      lastPasteInfo = { raw: rawText, normalized, issues, start, end: start + normalized.length };
      openPasteOverlay(lastPasteInfo);
    });

    // Main state
    let STATE = null;
    let controller = null;

    function setButtons(running) {
      generateBtn.disabled = running;
      uploadZipBtn.disabled = running;
      retryBtn.disabled = running || !STATE?.chunks?.some(c => c.status === "fail");
      downloadZipBtn.disabled = running || !STATE?.chunks?.some(c => c.status === "ok");
      downloadFullBtn.disabled = running || !STATE?.chunks?.every(c => c.status === "ok");
    }

    async function fetchChunkAudio({ text, model, voice, instructions }, signal) {
      const res = await fetch(`${API_BASE}/tts-chunk`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ text, model, voice, instructions }),
        signal
      });

      if (!res.ok) {
        const maybe = await res.json().catch(() => null);
        throw new Error(maybe?.error || `${res.status} ${res.statusText}`);
      }

      const buf = await res.arrayBuffer();
      return new Blob([buf], { type: "audio/mpeg" });
    }

    async function generateAll(state) {
      const concurrency = parseInt(concurrencySelect.value, 10) || 3;
      const model = state.model, voice = state.voice, instructions = state.instructions;

      state.running = true;
      setButtons(true);
      renderChunkRows(state);

      const total = state.chunks.length;
      let done = state.chunks.filter(c => c.status === "ok").length;

      setStatus(`Generating… (${done}/${total} complete)`);

      const items = state.chunks.map((c, idx) => ({ idx, text: c.text }));

      await runPoolAdaptive(
        items,
        async (item) => {
          const i = item.idx;
          const key = `${state.jobKey}:${pad3(i)}`;

          // already have it?
          const existing = await idbGet(key);
          if (existing?.blob) {
            state.chunks[i].status = "ok";
            done++;
            setStatus(`Generating… (${done}/${total} complete)`);
            renderChunkRows(state);
            return;
          }

          state.chunks[i].status = "run";
          state.chunks[i].error = "";
          renderChunkRows(state);

          try {
            const blob = await fetchChunkAudio({ text: item.text, model, voice, instructions }, controller.signal);
            await idbPut(key, blob, { jobKey: state.jobKey, index: i, title: state.title });
            state.chunks[i].status = "ok";
            done++;
          } catch (e) {
            state.chunks[i].status = "fail";
            state.chunks[i].error = e.message || String(e);
          }

          setStatus(`Generating… (${done}/${total} complete)`);
          renderChunkRows(state);
        },
        concurrency,
        controller.signal,
        (newMax) => setStatus(`Auto-drop: reducing concurrency to ${newMax} due to errors…`)
      );

      state.running = false;
      setButtons(false);

      const failed = state.chunks.filter(c => c.status === "fail").length;
      if (failed) {
        setStatus(`Done with errors. ${failed} chunk(s) failed. Use “Retry failed” or retry individual chunks.`);
      } else {
        setStatus(`All chunks complete. You can download ZIP or full MP3.`);
      }
      renderChunkRows(state);
    }

    async function retrySpecificChunk(state, chunkIndex) {
      if (state.running) return;
      controller = new AbortController();
      state.running = true;
      setButtons(true);

      const model = state.model, voice = state.voice, instructions = state.instructions;
      const key = `${state.jobKey}:${pad3(chunkIndex)}`;

      state.chunks[chunkIndex].status = "run";
      state.chunks[chunkIndex].error = "";
      renderChunkRows(state);
      setStatus(`Retrying chunk ${chunkIndex+1}/${state.chunks.length}…`);

      try {
        const blob = await fetchChunkAudio({ text: state.chunks[chunkIndex].text, model, voice, instructions }, controller.signal);
        await idbPut(key, blob, { jobKey: state.jobKey, index: chunkIndex, title: state.title });
        state.chunks[chunkIndex].status = "ok";
      } catch (e) {
        state.chunks[chunkIndex].status = "fail";
        state.chunks[chunkIndex].error = e.message || String(e);
      }

      state.running = false;
      setButtons(false);

      const failed = state.chunks.filter(c => c.status === "fail").length;
      setStatus(failed ? `Still failing: ${failed} chunk(s).` : `All chunks complete.`);
      renderChunkRows(state);
    }

    async function retryFailed(state) {
      if (state.running) return;
      controller = new AbortController();
      state.running = true;
      setButtons(true);

      const concurrency = parseInt(concurrencySelect.value, 10) || 3;
      const model = state.model, voice = state.voice, instructions = state.instructions;

      const failedIdx = state.chunks.map((c, i) => c.status === "fail" ? i : -1).filter(i => i >= 0);
      if (!failedIdx.length) {
        state.running = false;
        setButtons(false);
        return;
      }

      setStatus(`Retrying ${failedIdx.length} failed chunk(s)…`);
      renderChunkRows(state);

      await runPoolAdaptive(
        failedIdx,
        async (i) => {
          const key = `${state.jobKey}:${pad3(i)}`;
          state.chunks[i].status = "run";
          state.chunks[i].error = "";
          renderChunkRows(state);

          try {
            const blob = await fetchChunkAudio({ text: state.chunks[i].text, model, voice, instructions }, controller.signal);
            await idbPut(key, blob, { jobKey: state.jobKey, index: i, title: state.title });
            state.chunks[i].status = "ok";
          } catch (e) {
            state.chunks[i].status = "fail";
            state.chunks[i].error = e.message || String(e);
          }
          renderChunkRows(state);
        },
        concurrency,
        controller.signal,
        (newMax) => setStatus(`Auto-drop: reducing concurrency to ${newMax} due to errors…`)
      );

      state.running = false;
      setButtons(false);

      const still = state.chunks.filter(c => c.status === "fail").length;
      setStatus(still ? `Retry finished. Still failing: ${still} chunk(s).` : `All chunks complete.`);
      renderChunkRows(state);
    }

    // Buttons
    generateBtn.addEventListener("click", async () => {
      audioList.innerHTML = "";
      chunkListEl.innerHTML = "";
      setStatus("");

      const title = (titleInput.value.trim() || "Untitled").replace(/[\\/:*?"<>|]/g, "_");
      const text = textInput.value || "";
      const model = modelSelect.value;
      const voice = voiceSelect.value;
      const instructions = customInstr.value.trim();
      const chunkSize = Math.max(500, Math.min(6000, parseInt(chunkSizeInput.value, 10) || 2500));

      saveAdvancedSettings();

      if (!text.trim()) {
        setStatus("Enter text first.");
        return;
      }

      // Create stable jobKey so refresh/resume works
      const jobKey = await sha256(JSON.stringify({ title, text, model, voice, instructions, chunkSize }));

      const pieces = splitIntoChunks(text, chunkSize);

      // Build state
      STATE = {
        title, text, model, voice, instructions,
        chunkSize,
        jobKey,
        running: false,
        chunks: pieces.map(p => ({ text: p, len: p.length, status: "new", error: "" })),
      };

      // Load any existing chunks from IndexedDB
      for (let i = 0; i < STATE.chunks.length; i++) {
        const key = `${STATE.jobKey}:${pad3(i)}`;
        const rec = await idbGet(key);
        if (rec?.blob) STATE.chunks[i].status = "ok";
      }

      controller = new AbortController();
      await generateAll(STATE);
    });

    retryBtn.addEventListener("click", async () => {
      if (!STATE) return;
      controller = new AbortController();
      await retryFailed(STATE);
    });

    uploadZipBtn.addEventListener("click", () => uploadZipInput.click());

    uploadZipInput.addEventListener("change", async () => {
      const file = uploadZipInput.files?.[0];
      if (!file) return;

      try {
        uploadZipBtn.disabled = true;
        setStatus(`Reading ZIP: ${file.name}`);

        const buf = await file.arrayBuffer();
        const zip = await JSZip.loadAsync(buf);
        const entries = Object.values(zip.files)
          .filter(f => !f.dir && f.name.toLowerCase().endsWith(".mp3"))
          .sort((a, b) => a.name.localeCompare(b.name));

        if (!entries.length) {
          setStatus("No .mp3 files found inside the ZIP.");
          return;
        }

        const fd = new FormData();
        for (const entry of entries) {
          const blob = await entry.async("blob");
          const base = entry.name.split("/").pop() || entry.name;
          fd.append("files", blob, base);
        }

        const titleFromFile = file.name.replace(/\.zip$/i, "") || "Uploaded ZIP";
        setStatus(`Uploading ${entries.length} chunk(s) for concat…`);

        const res = await fetch(`${API_BASE}/concat-mp3`, { method: "POST", body: fd });

        if (!res.ok) {
          const maybe = await res.json().catch(() => null);
          throw new Error(maybe?.error || `${res.status} ${res.statusText}`);
        }

        const outBuf = await res.arrayBuffer();
        const finalBlob = new Blob([outBuf], { type: "audio/mpeg" });
        const url = URL.createObjectURL(finalBlob);

        audioList.innerHTML = `
          <div class="audio-item">
            <h3>${titleFromFile}</h3>
            <audio controls src="${url}"></audio><br/>
            <a href="${url}" download="${titleFromFile}.mp3">Download ${titleFromFile}.mp3</a>
          </div>
        `;

        setStatus("Concatenated audio ready.");
      } catch (e) {
        setStatus(`ZIP concat error: ${e.message || String(e)}`);
      } finally {
        uploadZipBtn.disabled = false;
        uploadZipInput.value = "";
      }
    });

    downloadZipBtn.addEventListener("click", async () => {
      if (!STATE) return;
      const zip = new JSZip();
      const prefix = `${STATE.jobKey}:`;

      const all = await idbGetAllByPrefix(prefix);
      const ok = all
        .map(x => ({ ...x, idx: parseInt(x.key.split(":")[1], 10) }))
        .filter(x => Number.isFinite(x.idx))
        .sort((a,b) => a.idx - b.idx);

      if (!ok.length) {
        setStatus("No completed chunks to zip.");
        return;
      }

      ok.forEach((rec) => {
        const idx = rec.idx;
        zip.file(`${STATE.title}_chunk_${pad3(idx)}.mp3`, rec.blob);
      });

      setStatus(`Building ZIP (${ok.length} file(s))…`);
      const blob = await zip.generateAsync({ type: "blob" });

      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = `${STATE.title}_chunks.zip`;
      a.click();
      setTimeout(() => URL.revokeObjectURL(url), 2000);
      setStatus("ZIP downloaded.");
    });

    downloadFullBtn.addEventListener("click", async () => {
      if (!STATE) return;
      if (!STATE.chunks.every(c => c.status === "ok")) {
        setStatus("All chunks must be complete before full concat.");
        return;
      }

      const prefix = `${STATE.jobKey}:`;
      const all = await idbGetAllByPrefix(prefix);
      const ordered = all
        .map(x => ({ ...x, idx: parseInt(x.key.split(":")[1], 10) }))
        .filter(x => Number.isFinite(x.idx))
        .sort((a,b) => a.idx - b.idx);

      if (ordered.length !== STATE.chunks.length) {
        setStatus("Missing some stored chunks. Re-generate or retry.");
        return;
      }

      const fd = new FormData();
      ordered.forEach((rec) => {
        fd.append("files", rec.blob, `chunk_${pad3(rec.idx)}.mp3`);
      });

      setStatus("Uploading chunks for concat…");
      downloadFullBtn.disabled = true;

      try {
        const res = await fetch(`${API_BASE}/concat-mp3`, {
          method: "POST",
          body: fd
        });

        if (!res.ok) {
          const maybe = await res.json().catch(() => null);
          throw new Error(maybe?.error || `${res.status} ${res.statusText}`);
        }

        const buf = await res.arrayBuffer();
        const fullBlob = new Blob([buf], { type: "audio/mpeg" });
        const url = URL.createObjectURL(fullBlob);

        audioList.innerHTML = `
          <div class="audio-item">
            <h3>${STATE.title}</h3>
            <audio controls src="${url}"></audio><br/>
            <a href="${url}" download="${STATE.title}.mp3">Download ${STATE.title}.mp3</a>
          </div>
        `;

        setStatus("Full MP3 ready.");
      } catch (e) {
        setStatus(`Concat error: ${e.message || String(e)}`);
      } finally {
        downloadFullBtn.disabled = false;
      }
    });

    // Keep buttons in sync
    const observer = new MutationObserver(() => {
      if (!STATE) {
        retryBtn.disabled = true;
        uploadZipBtn.disabled = false;
        downloadZipBtn.disabled = true;
        downloadFullBtn.disabled = true;
      } else {
        setButtons(STATE.running);
      }
    });
    observer.observe(statusDiv, { childList: true, subtree: true });
  </script>
</body>
</html>
